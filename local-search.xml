<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python基础-字符串与索引，循环</title>
    <link href="/2024/12/22/Python%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/12/22/Python%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础知识学习-2"><a href="#Python基础知识学习-2" class="headerlink" title="Python基础知识学习-2"></a>Python基础知识学习-2</h1><p>教程来自：<a href="http://www.runoob.com菜鸟教程,蓝桥云课/">www.runoob.com菜鸟教程，蓝桥云课</a></p><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。</p><h2 id="OZOLf">索引</h2><p>python的字串列表有2种取值顺序:</p><ul><li>从左到右索引默认0开始的，最大范围是字符串长度少1</li><li>从右到左索引默认-1开始的，最大范围是字符串开头</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34815153/1708499368705-a353e9e2-958a-4230-ae8a-d6f625315457.png"></p><p>[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; s = &#x27;abcdef&#x27;<br>&gt;&gt;&gt; s[1:5]<br>&#x27;bcde&#x27;<br></code></pre></td></tr></table></figure><p>当使用以冒号分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。</p><p>上面的结果包含了 s[1] 的值 b，而取到的最大范围不包括尾下标，就是 s[5] 的值 f。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34815153/1708499804665-26a73fd6-3e8e-4bd6-904b-4b0e78de9bd4.png"></p><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/34815153/1708500064318-a451684d-06b1-4986-b40d-9f8834a736d8.png"></p><h2 id="qbwuX">格式化字符串</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34815153/1679117284524-e230ccfa-04c9-4338-b617-e85e96b6bd71.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34815153/1678366368233-09150459-fd73-4f0c-99fa-5ff63b74352c.png"></p><h2 id="gbd10">循环</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34815153/1679116434532-8c3747d9-eb85-49de-964e-0273d890aa7b.png"></p><h3 id="EcsOl">for...in... 和while循环的区别</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/34815153/1679117983265-78aac3f8-9e4b-423a-a4ef-1e14fc3d64c2.png"></p><h3 id="EPehv">break 和continue()</h3><p>break() 停止当前循环</p><p>continue() 跳过当前循环轮次，执行下一轮</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-容器,迭代器,可迭代对象,生成器</title>
    <link href="/2024/10/22/Python%E5%9F%BA%E7%A1%80-%E5%AE%B9%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2024/10/22/Python%E5%9F%BA%E7%A1%80-%E5%AE%B9%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础知识学习-3"><a href="#Python基础知识学习-3" class="headerlink" title="Python基础知识学习-3"></a>Python基础知识学习-3</h1><p>教程来自：知乎专栏: <a href="https://zhuanlan.zhihu.com/p/319402935">https://zhuanlan.zhihu.com/p/319402935</a></p><p>Python中文指南1.0 <a href="https://python.iswbm.com/">https://python.iswbm.com/</a></p><h2 id="gRIhZ">1.容器contain</h2><p>容器就是存储某些元素的统称，它最大的特性就是判断一个元素是否在这个容器内。</p><p>在 Python 中，我们通常使用<font style="color:#117CEE;"> </font><font style="color:#DF2A3F;">in</font><font style="color:#117CEE;"> </font>或 <font style="color:#DF2A3F;">not in </font>来判断一个元素存在&#x2F;不存在于一个容器内。</p><p> str、list、tuple、set、dict 都可以通过 in 或 not in 来判断一个元素是否在存在&#x2F;不存在这个实例中，所以这些类型我们都可以称作「容器」</p><p>那为什么这些「容器」可以使用 in 或 not in 来判断呢？</p><p>这是因为它们都实现了<font style="color:#117CEE;"> </font><font style="color:#DF2A3F;"><strong>contains</strong> </font>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> item <span class="hljs-keyword">in</span> self.items<br><br>a = A()<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> a)   <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> a)   <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span> <span class="hljs-keyword">in</span> a)   <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><details class="lake-collapse"><summary id="uf7d96f41"><span class="ne-text" style="color: #DF2A3F">__init__</span><span class="ne-text">函数（方法）</span></summary><p id="uf3d57a77" class="ne-p"><span class="ne-text">在</span><span class="ne-text">Python</span><span class="ne-text">中定义类经常会用到__init__函数（方法），首先需要理解的是，两个下划线开头的函数是声明该属性为私有，不能在类的外部被使用或访问。而__init__函数（方法）支持带参数类的初始化，也可为声明该类的属性（类中的变量）。</span></p><p id="u53859226" class="ne-p"><span class="ne-text">__init__函数（方法）的第一个参数必须为self，后续参数为自己定义。</span></p><p id="uff2d3b4a" class="ne-p"><span class="ne-text">__init__()方法又被称为构造器（constructor）</span></p><pre data-language="python" id="Y142M" class="ne-codeblock language-python"><code>def __init__(self, width, height, depth):        self.width = width        self.height = height        self.depth = depth</code></pre></details><p>在这个例子中，类 A 定义了 <strong>contains</strong> 方法，所以我们就可以使用 1 in a 的方式去判断这个元素是否在 A 这个容器内。</p><p>换句话说，一个类只要实现了 <strong>contains</strong> 方法，那么它就是一个「容器」。</p><p>输出容器内的所有元素：例如执行 for x in [1, 2, 3]，就可以迭代出容器内的所有元素。</p><p>那使用这种方式输出元素，是如何实现的？这就跟「迭代器」有关了。</p><h2 id="n3uwz">2.可迭代对象</h2><p>可以利用 for 循环的对象，都叫可迭代对象。</p><p>譬如我们前面学过的 列表、元组、字典、字符串等都是可迭代对象。</p><h3 id="qdFd6">判断是否可迭代？</h3><p> Python 内置的 collections.abc 模块，在这个模块中提供了一个 Iterable 类，可以用<font style="color:#DF2A3F;"> isinstance </font>来判断。但是这种方法并不是百分百准确，最准确的方法，还是应该使用 for 循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], Iterable) <span class="hljs-comment"># 列表</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>&#125;, Iterable) <span class="hljs-comment"># 字典</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), Iterable) <span class="hljs-comment"># 元组</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&quot;hello&quot;</span>, Iterable) <span class="hljs-comment"># 字符串</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="ZrhQb">3.迭代器iterator</h2><p>当你对一个可迭代对象使用 iter 函数后，它会返回一个迭代器对象，对于迭代器对象，我们可以使用 next 函数，去获取元素，每执行一次，获取一次，等到全部获取完毕，会抛出 StopIteration 提示无元素可取。</p><p>一个对象要想使用 for 的方式迭代出容器内的所有数据，这就需要这个类实现「迭代器协议」。</p><p>也就是说，一个类如果实现了「迭代器协议」，就可以称之为「迭代器」。</p><p>什么是「迭代器协议」呢？</p><p>在 Python 中，实现迭代器协议就是实现以下 2 个方法：</p><ul><li>__iter__：这个方法返回对象本身，即 self</li><li>__next__：这个方法每次返回迭代的值，在没有可迭代元素时，抛出 StopIteration</li></ul><p>下面我们来看一个实现迭代器协议的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen = <span class="hljs-built_in">iter</span>(alist)<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen<br>&lt;list_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x100a94b20</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration <span class="hljs-comment">#没有可迭代元素了</span><br></code></pre></td></tr></table></figure><h2 id="Iod99">4.生成器Generator</h2><p>生成器Generator 是一个可以像迭代器那样使用for循环来获取元素的函数。<font style="color:#DF2A3F;">「生成器」是一个特殊的「迭代器」</font>，并且它也是一个「可迭代对象」。生成器的出现（Python 2.2 +），实现了延时计算，从而缓解了在大量数据下内存消耗过猛的问题。</p><p>当你在 Python Shell 中敲入一个生成器对象，会直接输出 generator object 提示你这是一个生成器对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; gen = (i for i in range(5))<br>&gt;&gt;&gt; gen<br>&lt;generator object &lt;genexpr&gt; at 0x10cae50b0&gt;<br></code></pre></td></tr></table></figure><h3 id="WuUrX">创建生成器：</h3><p>我们使用列表推导式时是下面这样子，使用 [] ，此时生成的是列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; mylist = [i for i in range(5)]<br>&gt;&gt;&gt; mylist<br>[0, 1, 2, 3, 4]<br></code></pre></td></tr></table></figure><p>而当你把 [] 换成 () ，返回的就不是列表了，而是一个生成器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; gen = (i for i in range(5))<br>&gt;&gt;&gt; gen<br>&lt;generator object &lt;genexpr&gt; at 0x10cae50b0&gt;<br></code></pre></td></tr></table></figure><h4 id="inVpe">使用 yield</h4><p>yield 是什么东西呢? 它相当于我们函数里的 return，但与 return 又有所不同。普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把yield看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器）</p><ul><li>当一个函数运行到 yield 后，函数的运行会暂停，并且会把 yield 后的值返回出去。</li><li>若 yield 没有接任何值，则返回 None</li><li>yield 虽然返回了，但是函数并没有结束</li></ul><p>更详细的解释，参考这一篇：<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;starting...&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        res = <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;res:&quot;</span>,res)<br>g = foo()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g)) <br><br><span class="hljs-comment">#代码输出--------------</span><br>starting... <span class="hljs-comment">#对print(next(g))的执行；这是我们定义的foo函数中的print的内容</span><br><span class="hljs-number">4</span> <span class="hljs-comment">#res = yield 4，函数内返回的结果</span><br>******************** <span class="hljs-comment">#对print(&quot;*&quot;*20)的执行</span><br>res: <span class="hljs-literal">None</span> <span class="hljs-comment">#对print(next(g))执行，但是从程序暂停的地方开始执行的，但是赋值操作的右边是没有值的，res:None</span><br><span class="hljs-number">4</span> <span class="hljs-comment">#继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</span><br></code></pre></td></tr></table></figure><p>“解释代码运行顺序，相当于代码单步调试：</p><p>1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p><p>2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环</p><p>3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，</p><p>4.程序执行print(“*”<em>20)，输出20个</em></p><p>5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p><p>6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p><p>到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。”</p><h3 id="I1AZy">为什么用Generator</h3><p>为为什么用这个生成器，是因为如果用List的话，会占用更大的空间，比如说取0,1,2,3,4,5,6…………1000</p><p>你可能会这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>    a=n<br></code></pre></td></tr></table></figure><p>这个时候range(1000)就默认生成一个含有1000个数的list了，所以很占内存。</p><p>这个时候你可以用刚才的yield组合成生成器进行实现，它们以一种惰性（lazy）的方式生成值，逐个产生并返回，而不是一次性生成一个大的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;starting...&quot;</span>)<br>    <span class="hljs-keyword">while</span> num&lt;<span class="hljs-number">10</span>:<br>        num=num+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">yield</span> num<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> foo(<span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><h3 id="rzJPO">Generator使用</h3><p>从一个生成器对象中取出元素，和我们前面学过的通过切片slide访问列表中的元素不一样，它没有那么直观。</p><p>想要从生成器对象中取出元素，只有两种方法：</p><p>第一种方法：使用 next 方法一个一个地把元素取出来，如果元素全部取完了，生成器会抛出 StopIteration 的异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>gen = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x1072400b0</span>&gt;<br>    &gt;&gt;&gt; <span class="hljs-built_in">next</span>(gen)<br>    <span class="hljs-number">0</span><br>    &gt;&gt;&gt; <span class="hljs-built_in">next</span>(gen)<br>    <span class="hljs-number">1</span><br>    &gt;&gt;&gt; <span class="hljs-built_in">next</span>(gen)<br>    <span class="hljs-number">2</span><br>    &gt;&gt;&gt; <span class="hljs-built_in">next</span>(gen)<br>    Traceback (most recent call last):<br>    File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><p>第二种方法：使用 for 循环一个一个地迭代出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>gen = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen:<br>    ...     <span class="hljs-built_in">print</span>(i)<br>...<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="EkqNR">生成器的激活</h3><p>生成器对象，在创建后，并不会执行任何的代码逻辑。</p><p>想要从生成器对象中获取元素，那么第一步要触发其运行，在这里称之为激活。</p><p>方法有两种：</p><ol><li>使用next() ：上面已经讲过</li><li>使用generator.send(None)</li></ol><p>还以下面这段代码为例，可以看到 gen.send(None) 相当于执行了 next(gen)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_factory</span>(<span class="hljs-params">top=<span class="hljs-number">5</span></span>):<br>    ...     index = <span class="hljs-number">0</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">while</span> index &lt; top:<br>    ...         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;index 值为: &quot;</span> + <span class="hljs-built_in">str</span>(index))<br><span class="hljs-meta">... </span>        index = index + <span class="hljs-number">1</span><br><span class="hljs-meta">... </span>        <span class="hljs-keyword">yield</span> index<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">raise</span> StopIteration<br>...<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen = generator_factory()<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen.send(<span class="hljs-literal">None</span>)<br>index 值为: <span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>gen.send(<span class="hljs-literal">None</span>)<br>index 值为: <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="g4Lwe">生成器的状态</h3><p>生成器在其生命周期中，会有如下四个状态</p><ul><li>GEN_CREATED # 生成器已创建，还未被激活</li><li>GEN_RUNNING # 解释器正在执行（只有在多线程应用中才能看到这个状态）</li><li>GEN_SUSPENDED # 在 yield 表达式处暂停</li><li>GEN_CLOSED # 生成器执行结束</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客更新优化记录</title>
    <link href="/2024/10/07/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/10/07/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="博客更新优化记录"><a href="#博客更新优化记录" class="headerlink" title="博客更新优化记录"></a>博客更新优化记录</h1><h3 id="23-05"><a href="#23-05" class="headerlink" title="23-05"></a>23-05</h3><p>建站</p><h3 id="cC9aH">23-10-14</h3><p>域名购买配置；域名备案</p><h3 id="t5tSY">23-12-10</h3><p>腾讯云图床配置OSS，更新文章</p><h3 id="xBX9N">24-10-05 </h3><p>更新文章</p><h3 id="fc9RY">24-10-06</h3><p>文章分类整理，tag标签更新， 博客页头图片更新</p><h3 id="pfoL7">24-10-06</h3><p>域名重定向, 阿里云DNS加速，</p><p>图片渐进式加载（Progressive Loading）待学习设置</p><h3 id="k85sd">24-10-07</h3><p>之前想要用是腾讯云的CDN，个人用户有100GB的境内CDN流量包，由于内地访问加速要求备案，但是我域名是阿里云买的，就用不了腾讯云的，只好去阿里云购买CDN服务。</p><p>开通阿里云CDN（全站加速 DCDN，Dynamic Content Delivery Network），有免费的中国大陆内地下行流量50GB 1年试用服务<a href="https://free.aliyun.com/?amp;spm=5176.7933777.J_3537169050.5.7fa8496eDSIsNd&productCode=dcdn">阿里云免费试用 - 阿里云 (aliyun.com)</a>），设置流量剩余20%预警，但是还是怕攻击，因为用完50GB会自动转扣费。同样的，要能够使用内地CDN加速，网站需要经过ICP备案，还要写网站的用途及网站名称，且要填写服务器IP地址，不然无法备案；所以这个个人博客目前用不了CDN服务，但是试了试打开速度还行，就先这样吧。</p>]]></content>
    
    
    <categories>
      
      <category>关于博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>个人网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客优化思路</title>
    <link href="/2024/10/07/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"/>
    <url>/2024/10/07/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="博客优化思路"><a href="#博客优化思路" class="headerlink" title="博客优化思路"></a>博客优化思路</h1><p>本博客是基于Hexo框架，部署到GitHub Pages的。本以为这样省下了买云服务器的钱，后来发现购买域名，图片云存储，CDN加速也要花费不少，因为如果一个主页打开很慢，图片加载也很慢，给人的体验感实在太差了，要用心做好这些，必要的支出和学习还是不能少的；现在主页仍然有很多不完善的地方，有时间还是要好好打磨。</p><p>Hexo博客框架的官方站点-中文 <a href="https://hexo.io/zh-cn/">Hexo</a></p><h2 id="sK0QJ">主题</h2><p>Hexo博客有很多精美别致的主题，我选择的是Fluid主题，简洁优美</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E9%85%8D%E7%BD%AE">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><p><a href="https://hexo.fluid-dev.com/categories/">分类 - Hexo Theme Fluid (fluid-dev.com)</a></p><h2 id="gXp4B">博客主页图片更换</h2><p>官方文档：<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">配置指南 | Hexo Fluid 用户手册 (fluid-dev.github.io)</a></p><p>首页banner图片不超过1M，不然加载很慢，现在的首页图片压缩过了，但打开速度还是一般，之后应该设置渐进式加载感官上会好很多；文章内的图片设置的是lazy-load，而且图片是存储在腾讯云COS上的，打开速度还可以；最好还是要做CDN加速访问，但是要备案好麻烦，先暂时这样吧</p><h2 id="vsS5x">归档分类</h2><p><a href="https://zhuanlan.zhihu.com/p/348131730">hexo博客中tags与categories用法 - 知乎 (zhihu.com)</a></p><h2 id="g8Slj">翻译-双语博客（待实现）</h2><h3 id="Q9ZHL">方案1：做2套页面</h3><p><a href="https://aursus.github.io/hexo-bilingual">hexo-中英双语 hexo+butterfly | Aursus</a></p><p>因为机翻通常不够好，所以实际上是做了2种语言的主页，然后人工校对发布的内容，点击翻译时自动跳转到英文页面</p><h3 id="HvhyG">方案2：hexo-generator-i18n 插件</h3><h2 id="aLTea">提高响应速度</h2><h3 id="FMfF7">优化页面，节省资源</h3><p>基于 Hexo 搭建的博客将更多的模块和页面逻辑移动到了前端页面之中，造成的就是打开慢，加载时间长</p><p><a href="https://imkero.net/posts/hexo-page-performance/">秒开的艺术：Hexo 博客首屏耗时优化实践 - 电脑星人 (imkero.net)</a></p><h3 id="nDrBU">CDN加速</h3><p>CDN加速是最直接快速的方法了，CDN<code>Content Delivery Network</code>内容分发网络，是一种将网络内容分发到多个地理位置的网络，以减少用户访问内容时的延迟。CDN的基本思路是将用户请求导向里用户最近的服务节点，使内容传输得更快、更稳定。CDN服务提供商必须具备CDN许可证，才能合法开展业务。</p><p>CDN的工作原理就是将源站的资源缓存到位于全国各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、分担源站压力，保证用户访问资源的速度和体验。<a href="https://cloud.tencent.com/developer/article/1779335">什么是CDN？它解决了什么难题？5分钟让你明明白白！-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h4 id="do2Ig">方案1： jsDelivr</h4><p>使用jsDelivr 做CDN加速</p><p>jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。官网：<a href="https://www.jsdelivr.com/">jsDelivr - A free, fast, and reliable CDN for JS and open source</a></p><p>参考这个博主<a href="https://zhiguoxin.blog.csdn.net/article/details/104703163?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-104703163-blog-106642303.235%5Ev43%5Epc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-104703163-blog-106642303.235%5Ev43%5Epc_blog_bottom_relevance_base1&utm_relevant_index=5">使用Jsdelivr CDN加速博客访问速度-CSDN博客</a></p><h4 id="m5dG3">方案2：腾讯云 Coding 平台</h4><p>使用腾讯云 Coding 平台做CDN加速</p><p><a href="https://blog.luzy.top/posts/2009685483/">Hexo折腾系列（一）博客访问速度优化 - 江风引雨の小po站 (luzy.top)</a></p><p><a href="https://cloud.tencent.com/developer/article/2005380">使用新版 CODING 静态网站服务 创建 Hexo 博客-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>CODING 平台本身不收取任何费用。静态网站服务需调用腾讯云<a href="https://cloud.tencent.com/product/cos?from_column=20065&from=20065">对象存储</a> COS、<a href="https://cloud.tencent.com/product/cdn?from_column=20065&from=20065">内容分发网络</a> CDN、SSL 证书产品等资源，其中 COS 和 CDN 采用用量计费模式，SSL 证书免费。</p><h4 id="方案3：阿里云DNS"><a href="#方案3：阿里云DNS" class="headerlink" title="方案3：阿里云DNS"></a>方案3：阿里云DNS</h4><p>域名是从阿里云购买的，所以选择阿里云DNS，19.9个人用户一年，但是不包DNS攻击防御；</p><p>开通阿里云CDN（全站加速 DCDN（Dynamic Content Delivery Network），有免费的中国大陆内地下行流量50GB 1年 试用服务）</p><h2 id="BBRlr">首页图片渐进式加载（待实现）</h2><p>渐进式加载比突兀的图片自上而下加载更美观</p><p>[图片渐进式加载的实现方法 | 存在感消失的地方|ω•&#96;) (akarin.dev)](<a href="https://akarin.dev/2021/11/04/progressive-image-loading/">https://akarin.dev/2021/11/04/progressive-image-loading/</a>)</p><h2 id="SA3Z0">网站安全防护</h2><p>这是最重要的一点了，网络安全学习也得加上，未雨绸缪啊</p><p>[DDOS 攻击的防范教程 - 阮一峰的网络日志 (ruanyifeng.com)](<a href="https://www.ruanyifeng.com/blog/2018/06/ddos.html#:~:text=%E8%BF%99%E5%B0%B1%E6%98%AF">https://www.ruanyifeng.com/blog/2018/06/ddos.html#:~:text=这就是</a> DDOS 攻)</p>]]></content>
    
    
    <categories>
      
      <category>关于博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客，个人网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础-列表，元组，字典，集合</title>
    <link href="/2024/10/06/Python%E5%9F%BA%E7%A1%80-%E5%88%97%E8%A1%A8%EF%BC%8C%E5%85%83%E7%BB%84%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88/"/>
    <url>/2024/10/06/Python%E5%9F%BA%E7%A1%80-%E5%88%97%E8%A1%A8%EF%BC%8C%E5%85%83%E7%BB%84%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基础知识学习-1"><a href="#Python基础知识学习-1" class="headerlink" title="Python基础知识学习-1"></a>Python基础知识学习-1</h1><p>教程来自：<a href="https://python.iswbm.com/">https://python.iswbm.com/</a>  Python中文指南, 更详细的示例</p><h2 id="JhlzS">列表list</h2><p><font style="color:#DF2A3F;">list()</font> 创建空表格或<font style="color:#DF2A3F;">[ ] </font>方括号创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">创建列表有两种方法<br><br>第一种方法：先创建空列表实例，再往实例中添加元素<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones = <span class="hljs-built_in">list</span>()   <span class="hljs-comment"># 实例化</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.append(<span class="hljs-string">&quot;Apple&quot;</span>)  <span class="hljs-comment"># append添加元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.append(<span class="hljs-string">&quot;Huawei&quot;</span>)  <span class="hljs-comment"># 添加元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.append(<span class="hljs-string">&quot;Xiaomi&quot;</span>)  <span class="hljs-comment"># 添加元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>]<br><br>第二种方法：直接定义列表，并填充元素。推荐第二种<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="eW1Vm"> 元组tuple </h2><p> 与列表不同,元组是不可变的，或者说元组中的元素值是不可改（增删）的，但是可以对整个元组进行操作：<a href="https://www.runoob.com/python/python-tuples.html"> https://www.runoob.com/python/python-tuples.html</a></p><p> 使用<font style="color:#DF2A3F;">tuple() 或()</font> 圆括号创建</p><p> 当你创建只包含一个元素的元组时，要在第一个元素后面加一个逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ctuple = (<span class="hljs-number">1</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(ctuple) <span class="hljs-comment">#R语言中是class()</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt; <br></code></pre></td></tr></table></figure><p> 但是可以通过 +、* 添加元素，这里理解为重新定义了新的tuple</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>a+=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment"># 输出 (1,2,3,4,5,6)</span><br><br>b=a*<span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-comment"># 输出 (1, 2, 3, 1, 2, 3, 1, 2, 3)</span><br></code></pre></td></tr></table></figure><h2 id="cJspQ"> 字典dict</font></h2><p> 字典（英文名 dict），它是由一系列的键值（key-value）对组合而成的数据结构。字典是另一种可变容器模型，且可存储任意类型对象。</p><p> 字典的每个键值<font style="color:#DF2A3F;"> key: value </font> 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 。</p><p> 字典中的每个键都与一个值相关联，其中</p><ol><li>键，必须是可 hash 的值，如字符串，数值等</li><li>值，则可以是任意对象</li></ol><p> 键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。</p><p> 第一种方法 ：先使用dict()创建空字典实例，再往实例中添加元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; profile = dict(name=&quot;王炳明&quot;, age=27, 众号=&quot;ython编程时光&quot;)<br>&gt;&gt;&gt; profile<br>&#123;&#x27;name&#x27;: &#x27;王炳明&#x27;, &#x27;age&#x27;: 27, &#x27;众号&#x27;: &#x27;ython编程时光&#x27;&#125;<br></code></pre></td></tr></table></figure><p> 第二种方法 ：直接使用 {}定义字典，并填充元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; profile = &#123;&quot;name&quot;: &quot;王炳明&quot;, &quot;age&quot;: 27, &quot;公众号&quot;: &quot;Python编程时光&quot;&#125;<br>&gt;&gt;&gt; profile<br>&#123;&#x27;name&#x27;: &#x27;王炳明&#x27;, &#x27;age&#x27;: 27, &#x27;公众号&#x27;: &#x27;Python编程时光&#x27;&#125;<br></code></pre></td></tr></table></figure><p> 第三种方法 ：使用 dict()构造函数可以直接从键值对序列里创建字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; info = [(&#x27;name&#x27;, &#x27;王炳明 &#x27;), (&#x27;age&#x27;, 27), (&#x27;公众号&#x27;, &#x27;Python编程时光&#x27;)]<br>&gt;&gt;&gt; dict(info)<br>&#123;&#x27;name&#x27;: &#x27;王炳明 &#x27;, &#x27;age&#x27;: 27, &#x27;公众号&#x27;: &#x27;Python编程时光&#x27;&#125;<br></code></pre></td></tr></table></figure><p> 第四种方法：使用字典推导式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; adict = &#123;x: x**2 for x in (2, 4, 6)&#125;<br>&gt;&gt;&gt; adict<br>&#123;2: 4, 4: 16, 6: 36&#125;<br></code></pre></td></tr></table></figure><h3 id="C3kUF"> 重要方法</font></h3><h4 id="byVQV"> 判断Key 是否存在</font></h4><p> 使用<font style="color:#DF2A3F;">in  和 </font><font style="color:#DF2A3F;">not in </font> 来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> profile<br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-keyword">in</span> profile<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h4 id="pd4AP"> 设置默认值</font></h4><p> 要给某个 key 设置默认值，最简单的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">profile = &#123;&quot;name&quot;: &quot;王炳明&quot;, &quot;age&quot;: 27, &quot;公众号&quot;: &quot;Python编程时光&quot;&#125;<br><br>if &quot;gender&quot; not in profile:<br>    profile[&quot;gender&quot;] = &quot;male&quot;<br></code></pre></td></tr></table></figure><p> 更简单的办法 .setdefault()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">profile = &#123;&quot;name&quot;: &quot;王炳明&quot;, &quot;age&quot;: 27, &quot;公众号&quot;: &quot;Python编程时光&quot;&#125;<br>profile.setdefault(&quot;gender&quot;, &quot;male&quot;)<br></code></pre></td></tr></table></figure><h2 id="oJUnx"> 集合set</font></h2><p> 集合（英文名 set），它是一个无序的不重复元素序列。</p><p> 第一种方法：使用 花括号<font style="color:#DF2A3F;"> {} </font> 直接创建，创建的时候，{} 可以包含有重要的元素，但是创建完后，集合会去重，只留第一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = &#123;&quot;Apple&quot;, &quot;Huawei&quot;, &quot;Xiaomi&quot;&#125;<br>&gt;&gt;&gt; aset<br>set([&#x27;Huawei&#x27;, &#x27;Xiaomi&#x27;, &#x27;Apple&#x27;])<br></code></pre></td></tr></table></figure><p> 第二种方法：使用<font style="color:#DF2A3F;">set() </font> 方法进行创建，当set() 函数不接任何参数时，创建的是空集合，如果不创建空集合，可以传入一个列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; bset = set()  # 空集合<br>&gt;&gt;&gt; bset<br>set([])<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; cset = set([&quot;Apple&quot;, &quot;Huawei&quot;, &quot;Xiaomi&quot;])<br>&gt;&gt;&gt; cset<br>set([&#x27;Huawei&#x27;, &#x27;Apple&#x27;, &#x27;Xiaomi&#x27;])<br></code></pre></td></tr></table></figure><h3 id="ld7M3"> 增删查改</font></h3><h4 id="Ky5XS"> 增加元素</font></h4><p> 使用<font style="color:#DF2A3F;"> update </font> 函数，来往集合中添加元素。update 函数后可接集合，列表，元组，字典等。</p><p> 这是接集合的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = set()<br>&gt;&gt;&gt; aset<br>set([])<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # 接集合<br>&gt;&gt;&gt; aset.update(&#123;&quot;Apple&quot;&#125;)<br>&gt;&gt;&gt; aset<br>set([&#x27;Apple&#x27;])<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # 接列表<br>&gt;&gt;&gt; aset.update([&quot;Huawei&quot;])<br>&gt;&gt;&gt; aset<br>set([&#x27;Huawei&#x27;, &#x27;Apple&#x27;])<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # 接元组<br>&gt;&gt;&gt; aset.update((&quot;Xiaomi&quot;,))<br>&gt;&gt;&gt; aset<br>set([&#x27;Huawei&#x27;, &#x27;Apple&#x27;, &#x27;Xiaomi&#x27;])<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # 接字典<br>&gt;&gt;&gt; aset.update(&#123;&quot;VIVO&quot;: &quot;xxxx&quot;&#125;)<br>&gt;&gt;&gt; aset<br>set([&#x27;Huawei&#x27;, &#x27;Apple&#x27;, &#x27;VIVO&#x27;, &#x27;Xiaomi&#x27;])<br></code></pre></td></tr></table></figure><h4 id="HJAql"> 删除元素</font></h4><p> 使用<font style="color:#DF2A3F;">remove </font> 函数可以删除集合中的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = &#123;&quot;Apple&quot;, &quot;Huawei&quot;, &quot;Xiaomi&quot;&#125;<br>&gt;&gt;&gt; aset.remove(&quot;Xiaomi&quot;)<br>&gt;&gt;&gt; aset<br>set([&#x27;Huawei&#x27;, &#x27;Apple&#x27;])<br></code></pre></td></tr></table></figure><p> 使用remove函数，如果对应的元素不存在，是会报错的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = &#123;&quot;Apple&quot;, &quot;Huawei&quot;, &quot;Xiaomi&quot;&#125;<br>&gt;&gt;&gt; aset.remove(&quot;VIVO&quot;)<br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>KeyError: &#x27;VIVO&#x27;<br></code></pre></td></tr></table></figure><p> 对于这种情况，你可以使用 discard函数，存在元素则移除，不存在也不会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = &#123;&quot;Apple&quot;, &quot;Huawei&quot;, &quot;Xiaomi&quot;&#125;<br>&gt;&gt;&gt; aset.discard(&quot;VIVO&quot;)<br>&gt;&gt;&gt; aset<br>set([&#x27;Huawei&#x27;, &#x27;Xiaomi&#x27;, &#x27;Apple&#x27;])<br></code></pre></td></tr></table></figure><h4 id="nKvIX"> 修改元素</font></h4><p> 文章开头处，已经说明了集合是无序的，因此集合是 没有索引的。</p><p> 既然没有索引，修改也无从谈起。</p><p> 记住：集合只有添加元素、删除元素。</p><h4 id="s3nFy"> 查询元素</font></h4><p> 同上，没有顺序，也就没有索引，查询也无从谈起。</p><p> 但是可以查看集合的长度<font style="color:#DF2A3F;"> len()</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = &#123;&quot;Apple&quot;, &quot;Huawei&quot;, &quot;Xiaomi&quot;&#125;<br>&gt;&gt;&gt; len(aset)<br>3<br></code></pre></td></tr></table></figure><h4 id="GkXj2"> 集合运算</font></h4><p> 合并：<font style="color:#DF2A3F;">union </font>,合并 时会去掉重复的部分</p><p> 交集：<font style="color:#DF2A3F;">intersection </font> 函数</p><p> 如果计算两个集合中不重复的元素集合，可以使用 symmetric_difference  函数</p><h3 id="fZ77d"> 集合判断</font></h3><h4 id="P5t9o"> 判断是否有某元素 in</font></h4><p> R语言是 %in%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = &#123;&quot;Apple&quot;, &quot;Huawei&quot;&#125;<br>&gt;&gt;&gt; &quot;Apple&quot; in aset<br>True<br></code></pre></td></tr></table></figure><h4 id="Ww0ij"> 判断两集合是否有相同元素 </font><font style="color:#DF2A3F;">.isdisjoint</font></h4><p>  如果两集合有相同元素，则返回 False，如果没有相同元素，则返回 True</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = &#123;&quot;Apple&quot;, &quot;Huawei&quot;&#125;<br>&gt;&gt;&gt; bset = &#123;&quot;Xiaomi&quot;, &quot;Huawei&quot;&#125;<br>&gt;&gt;&gt; aset.isdisjoint(bset)<br>False<br></code></pre></td></tr></table></figure><h4 id="CyTRE"> 判断是否是子集</font><font style="color:#DF2A3F;"> .issubset</font></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&gt;&gt;&gt; aset = &#123;&quot;Apple&quot;, &quot;Huawei&quot;&#125;<br>&gt;&gt;&gt; bset = &#123;&quot;Huawei&quot;&#125;<br>&gt;&gt;&gt; bset.issubset(aset)<br>True<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>R语言数据分析常用操作</title>
    <link href="/2024/10/06/R%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/10/06/R%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="R语言数据分析常用操作"><a href="#R语言数据分析常用操作" class="headerlink" title="R语言数据分析常用操作"></a>R语言数据分析常用操作</h1><h2 id="XYlBS">零、内存管理</h2><p>及时清除不需要的变量，如超大的原始矩阵</p><p>更新了新的Rstudio 版本(2023.06.1+524 ) 后，可直接rm()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">rm(exp_of_gene,Lung_sum_Expr) # rm() 清除环境变量<br>gc() #释放内存，多运行几次<br></code></pre></td></tr></table></figure><h2 id="qMyEn">一、常用操作</h2><p>重复值操作</p><p>重命名</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs r">dfnew <span class="hljs-operator">&lt;-</span> df<span class="hljs-punctuation">[</span><span class="hljs-operator">!</span>duplicated<span class="hljs-punctuation">(</span>df<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">#删除数据框中有重复的行</span><br><span class="hljs-built_in">sum</span><span class="hljs-punctuation">(</span>duplicated<span class="hljs-punctuation">(</span>df<span class="hljs-operator">$</span>id<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#查询有几行重复</span><br>duplicated<span class="hljs-punctuation">(</span>df<span class="hljs-operator">$</span>id<span class="hljs-punctuation">)</span> <span class="hljs-comment">#数据某列是否有重复</span><br>which<span class="hljs-punctuation">(</span>duplicated<span class="hljs-punctuation">(</span>df<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#重复数据所在行</span><br><br><br><span class="hljs-comment"># 重命名一个列的名称，根据index或者是根据column name获取得到index</span><br>colnames<span class="hljs-punctuation">(</span>df<span class="hljs-punctuation">)</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>var_test<span class="hljs-punctuation">)</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>var_test<span class="hljs-punctuation">)</span><span class="hljs-operator">==</span><span class="hljs-string">&quot;y_slide_mm&quot;</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">&lt;-</span> <span class="hljs-string">&quot;Y&quot;</span><br></code></pre></td></tr></table></figure><p>删除</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-comment">## R语言删除某列</span><br>library<span class="hljs-punctuation">(</span>dplyr<span class="hljs-punctuation">)</span><br><span class="hljs-comment">## 按索引删除</span><br>data <span class="hljs-operator">&lt;-</span> select<span class="hljs-punctuation">(</span>data<span class="hljs-punctuation">,</span><span class="hljs-operator">-</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment">## 按列名删除单列</span><br>data <span class="hljs-operator">&lt;-</span> select<span class="hljs-punctuation">(</span>data<span class="hljs-punctuation">,</span><span class="hljs-operator">-</span>lieming<span class="hljs-punctuation">)</span><br><span class="hljs-comment">## 按列名删除多列</span><br>data <span class="hljs-operator">&lt;-</span> select<span class="hljs-punctuation">(</span>data<span class="hljs-punctuation">,</span><span class="hljs-operator">-</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>lieming1<span class="hljs-punctuation">,</span>lieming2<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br></code></pre></td></tr></table></figure><h2 id="M5Pe0">二、绘图</h2><h3 id="TJ16n">（1）调整坐标轴刻度</h3><p>scale_x_continuous</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">plot<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> scale_x_continuous<span class="hljs-punctuation">(</span>breaks<span class="hljs-operator">=</span>seq<span class="hljs-punctuation">(</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> 调整X轴刻度<br></code></pre></td></tr></table></figure><h3 id="wb3Dt">（2）散点、火山图标签</h3><p>ggrepel::geom_text_repel()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">library(ggrepel)<br><br>p+ggrepel::geom_text_repel(<br>  aes(label=gene,color=cd),df2,<br>  size = 4, #注释文本的字体大小<br>  box.padding = 0.5, #字到点的距离<br>  point.padding = 0.8, #字到点的距离，点周围的空白宽度<br>  min.segment.length = 0.5, #短线段可以省略<br>  segment.color = &quot;black&quot;, #segment.colour = NA, 不显示线段<br>  show.legend = F)<br>ggsave(&quot;tmp4.pdf&quot;,width = 22, height = 20, units = c(&quot;cm&quot;))<br></code></pre></td></tr></table></figure><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1686121218117-cba7a2d4-e1e7-4d8c-b9b7-34a41e08cf78.webp"></p><h3 id="zSu1R">（3）调整绘图页面边距，坐标轴字显示不全</h3><p>par(mar&#x3D;c(5,5,5,5))默认外边框的大小为mar&#x3D;c(5.1,4.1,4.1,2.1), 分别对应下，左，上，右四个外边框</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1690529464410-4945b604-c038-49cc-b584-ae46ddf4c227.png"></p><p><font style="color:rgb(47, 47, 47);">R绘图区域（如上图），主要分为两部分</font></p><p>一是外围边距（out margin area,oma）；</p><p>二是绘图区域，绘图区域又细分为两个部分：绘图边距margins和主绘图(main plot area)</p><p><strong><font style="color:rgb(34, 28, 28);">外围边距</font></strong><font style="color:rgb(34, 28, 28);">可使用</font><font style="color:rgb(34, 28, 28);">par()</font><font style="color:rgb(34, 28, 28);">函数中的</font><font style="color:rgb(34, 28, 28);">oma</font><font style="color:rgb(34, 28, 28);">来进行设置。</font><font style="color:rgb(34, 28, 28);">oma</font><font style="color:rgb(34, 28, 28);">即</font><font style="color:rgb(34, 28, 28);">out margin area</font><font style="color:rgb(34, 28, 28);">，例如</font><font style="color:rgb(34, 28, 28);">oma&#x3D;c(5,4,3,2)</font><font style="color:rgb(34, 28, 28);">，这里指外围边距分别为下边距：</font>5行，左边距4行，上边距3行，右边距2行，这里的行是指可以显示1行普通字体。注意，oma()设置顺序是从bottom开始，按照bottom,left,top,right方向设置，也就是从bottom开始按照顺时针方向设置。</p><p><strong><font style="color:rgb(34, 28, 28);">绘图边距</font></strong><font style="color:rgb(34, 28, 28);">（margins）可以使用par()函数中mar来设置。比如mar&#x3D;c(5,4,3,2)，与外围边距的设置类似，是指绘图边距分别为下边距：5行，左边距4行，上边距3行，右边距2行。参数设置顺序与oma()顺序一直，也是从bottom开始顺时针方向设置。</font></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">par<span class="hljs-punctuation">(</span>oma<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> mar<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#通常设置mar就行</span><br></code></pre></td></tr></table></figure><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1690529650475-eab8e20f-0f06-4648-af69-1c7102b4d20c.png" alt="par(oma=c(3,3,3,3), mar=c(5,5,5,5))"></p><h2 id="VHuR6">三、配色网站</h2><p>十六进制颜色，左侧可选各种风格</p><p><a href="https://color.dumogu.top/">一个好用的配色网站! 毒蘑菇 - 配色</a></p><p><a href="https://www.colorhunt.co/">Color Palettes for Designers and Artists - Color Hunt</a></p><p><a href="http://www.yinhuafeng.cn/daohang/peise/#hue_4">http://www.yinhuafeng.cn/daohang/peise/#hue_4</a>  打开很快</p><h2 id="oAR3e">四、数据</h2><p>数据是否取过log 的粗略估计</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-comment">#通过直方图看矩阵是否取过log，取过会更接近正态分布</span><br><span class="hljs-comment"># 假设exprMatrix是你的RNA-Seq表达矩阵</span><br><span class="hljs-comment"># 选择一个基因（假设基因名为&quot;Gene1&quot;）进行观察</span><br>GEtest <span class="hljs-operator">&lt;-</span> Lung_sum_Expr<span class="hljs-punctuation">[</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;TSPAN6&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-comment"># 绘制基因表达量的直方图</span><br>hist<span class="hljs-punctuation">(</span>GEtest<span class="hljs-punctuation">,</span> breaks <span class="hljs-operator">=</span> <span class="hljs-number">30</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h2 id="CWlmp">五、Tools</h2><p>斜杠反斜杠转换: <a href="https://www.tuziang.com/tool/slashConversion/index.html">windows斜杠转换-在线工具</a></p><h2 id="R3zMr">六、加快运行速度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">#试着调用CPU多核性能-----------------<br>library(future)<br>plan() # check the current active plan<br># change the current plan to access parallelization<br>plan(multisession, workers=32) #开启多核运算，最好不要超过物理核心数，内存容量不够的话会有瓶颈<br>options(future.globals.maxSize = 20 * 1024^3)<br>plan(&#x27;sequential&#x27;) #终止多核运算<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>R语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>R语言</tag>
      
      <tag>数据分析</tag>
      
      <tag>生信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用指令</title>
    <link href="/2024/10/06/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2024/10/06/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux系统结构和常用指令"><a href="#Linux系统结构和常用指令" class="headerlink" title="Linux系统结构和常用指令"></a>Linux系统结构和常用指令</h1><p>教程来自蓝桥云课（原实验楼）</p><h2 id="euPv5">系统结构</h2><p>Linux 系统重要的概念是：一切皆文件。比如进程，我们挂载的磁盘，这些都被视为文件，这些文件也有它们固定的名称，如 “&#x2F;proc “, “ &#x2F;dev”</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678016586193-d687f71e-46b4-4a44-9f89-984071d074ed.png"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678362280661-342564d7-5b5d-4eae-b956-3bd09dc4ac7c.png"></p><h3 id="rLvhp">目录路径</h3><p>cd命令切换路径</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678016940816-b9f8c291-261b-40b7-832a-10ff2b577505.png"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678017067375-920322f8-ecad-4415-bf74-6c25fff73e7c.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">绝对路径<span class="hljs-built_in">cd</span> /usr/local/bin</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">相对路径<span class="hljs-built_in">cd</span> ../../usr/local/bin</span><br></code></pre></td></tr></table></figure><h4 id="pOwTP">一、新建</h4><h5 id="nb4Iv">1.新建空白文件</h5><p>touch命令</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678017606156-8f664351-4845-4f83-8a71-776593aa9af8.png"></p><h5 id="h4LD1">2.新建目录</h5><p>mkdir命令创建一个空目录（make directories）</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678017717680-1c4ce464-535b-40e8-a578-ada6031c663b.png"><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678017871328-6981ef2e-6be8-4fec-8f11-bff097594a76.png"></p><h4 id="vMKNC">二、复制</h4><h5 id="fzsfw">1.复制文件</h5><p>cp命令（copy）复制</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678018093377-05ff13f4-383a-4d46-a9cc-1ba4a92fca30.png"></p><h4 id="YWGg9">三、删除</h4><h5 id="uvjz2">1.删除文件</h5><p>rm命令(remove files or directories)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm test<br>rm -f test #强制删除，忽略只读权限<br>rm -rf #命令意味着递归地、强制删除指定的目录;rm 命令不能被用来直接删除目录（文件夹）。你必须在 rm 命令中使用递归选项 -r<br><br>rm -rf 文件/目录  //删除文件或目录<br>rm -rf *.c    //*是一种通配结构，既*是什么都可以，只要最后带有.c的文件会全被删除.相当于是xxx.c的文件都会被移除.<br>rm -rf *   //*后面什么都没加，说明这是删除所有文件（-r递归（删目录），-f强制）<br>rm -rf /  //直接将根目录下的所有文件全部删除，也就是我们口中所说的删库.<br><br></code></pre></td></tr></table></figure><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1725859301767-9de07cb6-fcec-40e6-8746-6451b9bae70c.png"></p><h5 id="BpKJV">2.删除目录 </h5><p>rm需加上-r参数，<code>&lt;font style=&quot;color:rgb(33, 150, 243);background-color:rgb(238, 238, 238);&quot;&gt;rm&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);"> 命令不能被用来直接删除目录（文件夹）。需要在 </font><code>&lt;font style=&quot;color:rgb(33, 150, 243);background-color:rgb(238, 238, 238);&quot;&gt;rm&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);"> 命令中使用递归选项 </font><code>&lt;font style=&quot;color:rgb(33, 150, 243);background-color:rgb(238, 238, 238);&quot;&gt;-r&lt;/font&gt;</code></p><h4 id="JLU7y">关于<font style="color:#DF2A3F;background-color:rgb(238, 238, 238);">rm -rf / </font></h4><p>From:<a href="https://linux.cn/article-13813-1.html">技术|Linux 黑话解释：什么是 sudo rm-rf？为什么如此危险？</a></p><p>rm -rf命令意味着递归地、强制删除指定的目录</p><p>sudo rm -rf &#x2F;   sudo开头 ：以 root 身份运行一个命令，这允许你对系统进行任何改变。sudo rm -rf &#x2F; 指删除 root 用户拥有的系统文件。</p><h4 id="JzG1k">四、移动文件与文件重命名</h4><h5 id="gTtxg">移动文件</h5><p>mv命令（move or rename files）移动或剪切文件</p><p>格式：mv 源目录文件 目的目录</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678018908578-2b998020-3051-42d8-b02b-4c63ec86fa7b.png"></p><h5 id="E60VP">重命名文件</h5><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678019310457-ef3ed804-c8ff-4da2-a0a7-ae6104b53ce6.png"></p><h5 id="znIDM">批量重命名</h5><p>rename命令要用perl正则表达式作为参数</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678019870318-0ee58542-b3f9-47db-98e0-a092a9f9e52c.png"></p><h4 id="HGgS8">五、查看文件</h4><p>1、使用cat, tac ,和nl命令查看文件</p><p>cat 命令：打印文件内容到标准输出（终端），正序显示</p><p>tac命令 ：打印文件内容到标准输出（终端），倒序显示</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678020630472-e1d0537c-cd6c-44f8-a5bf-a54f6d959d91.png"></p><h4 id="cHNqR">六、常用快捷键</h4><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1678362518346-b5473d3b-8f60-44cf-ad6b-f9637de8cd4a.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器操作：SSH 传输文件 图形界面窗口</title>
    <link href="/2024/10/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%EF%BC%9ASSH-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%AA%97%E5%8F%A3/"/>
    <url>/2024/10/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%EF%BC%9ASSH-%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器操作：SSH-传输文件-图形界面窗口"><a href="#服务器操作：SSH-传输文件-图形界面窗口" class="headerlink" title="服务器操作：SSH 传输文件 图形界面窗口"></a>服务器操作：SSH 传输文件 图形界面窗口</h1><p>主要使用Xshell, Xftp，Xmanager 这三个软件；Xshell, Xftp邮箱免费注册，Xmanager有激活文件。远程连接主机后就可以方便传输文件，Xmanager远程显示服务器上python IDE(这里使用的是Spyder)图形化界面</p><h2 id="FHSgw">Xshell</h2><p>文件-新建-新建会话属性  ；主机填上服务器IP地址 ；然后填上用户名和密码</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1725799874437-4a715e62-47e8-4461-9269-383d605dc75d.png"></p><p>Xftp，Xmanager 连接类似</p><h2 id="ppKxH">Xmanager</h2><h3 id="JrbSb">建立连接</h3><p>新建会话 填写主机IP地址</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1725800536239-05c5ba48-1b5e-49c0-8ace-382337ce2e56.png"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1725800571746-d58005d2-1e8f-42ce-935d-0cd1c2224e4e.png"></p><h3 id="Q8w2a">图形化界面显示</h3><p>Windows图标，找到下载的应用：Xmanager-Passive ,以管理员权限运行；点击后会以最小化方式运行；在服务器上打开spyder时就会显示图形化界面</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1725800926841-35f48cd2-9a7e-4bfd-9994-6ba9754a2ec6.png"></p><h2 id="IXD2H">Conda </h2><h3 id="tioRb">conda envs 创建到指定路径下</h3>注意，指定好环境安装的路径后一定要用append给环境命名<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs r">conda create <span class="hljs-operator">-</span><span class="hljs-operator">-</span>prefix<span class="hljs-operator">=</span><span class="hljs-operator">/</span>data<span class="hljs-operator">/</span><span class="hljs-number">0</span>_czh<span class="hljs-operator">/</span>test_env python<span class="hljs-operator">=</span><span class="hljs-number">3.11</span>  <span class="hljs-comment"># -p 指定路径</span><br><span class="hljs-comment">#注意，创建好的环境此时没有名字</span><br>conda config <span class="hljs-operator">-</span><span class="hljs-operator">-</span>append envs_dirs <span class="hljs-operator">/</span>data<span class="hljs-operator">/</span><span class="hljs-number">0</span>_czh <span class="hljs-comment">#环境命名</span><br></code></pre></td></tr></table></figure><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1725799661705-90de176a-1be3-47b5-8339-eaccef47e48e.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>Linux</tag>
      
      <tag>Conda环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51单片机学习</title>
    <link href="/2024/10/05/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/05/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="51单片机学习"><a href="#51单片机学习" class="headerlink" title="51单片机学习"></a>51单片机学习</h1><p>教程来自B站：江协科技 ， 非常好的UP主！江协科技的主页：<a href="https://jiangxiekeji.com/about.html">关于我们 (jiangxiekeji.com)</a></p><h2 id="qsiiN">一、准备材料</h2><p>51单片机开发板</p><p>软件：keil5(编写程序), STC-ISP（程序烧录到单片机）</p><p>开发板驱动安装，驱动程序安装在C盘下；设备管理器下，端口显示CH340</p><h2 id="ACXMa">二、点亮LED</h2><h3 id="ewra5">2-1 点亮一个LED</h3><p>μVision新建工程</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709285017634-a2230256-38e5-48a0-a1d2-ff1d5e5853d9.png"></p><p>选择单片机芯片公司Atmel； AT89C52</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709285532410-45a41197-53f1-4f5f-9e2e-27ae7e79eacf.png"></p><p>新建project后，左侧可以看到工程文件夹，Source Group存放代码，新建C语言文件</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709285668122-9448bd68-064d-48b7-9c12-be4a27954ec2.png"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709285798895-a96c17c2-c956-4f3a-8e2e-1597f8a6067d.png"></p><h4 id="PqAJ2">添加主函数 void main()</h4><p>{}两个花括号之间缩进一个tab</p><h4 id="IRtLc">开发板LED模块</h4><p>VCC：电源正极</p><p>从VCC，经过电阻</p><p>开发板上电阻写了102，理解为10的后面补2个零，1000&#x3D;1K，最后一位数字代表倍率</p><p>左侧红色的P2数字指连接的单片机引脚，由于二极管特性，当P20输出高电平（5V），LED不会亮；输出低电平（0V），电流由正到负，灯亮。电流方向从右到左</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709286442325-8c9126dd-e841-496f-92f9-7da10b3cb3b8.png"></p><p>那么，单片机是如何控制输出的电流大小呢</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709287328957-2686b900-359e-43cc-9f7e-c7d3dd2c7f99.png"></p><p>如上，单片机(MCU)内CPU向寄存器内写入1，通过驱动器放大，通过IO口输出5V高电平；写0则低电平</p><h4 id="qYeHy">代码</h4><p>记得添加头文件，里面包含了寄存器地址</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709287964034-8c170191-da59-4e02-97a1-d3014dc2129f.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>P2=<span class="hljs-number">0xFE</span>;<span class="hljs-comment">//1111 1110</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//while(1),True,porgram run</span><br>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>0x 指用的是十六进制</p><p>P2寄存器（8位）写入，控制电流；1111 1110，但机器不识别这样写，用十六进制</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709288697932-5519fac9-21a0-4505-bb50-3ade90e04e0d.png" alt="Create HEX File; Build编译"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709387179479-2ec0c8c8-f06c-4208-94ca-8d1ef58652e4.png"></p><h4 id="i5gZc">程序写入单片机</h4><p>STC-ISP 软件，找到对应的单片机(STC89C52RC)及串口型号CH340; 购买的板子和B站江协老师的有点不同</p><p>芯片型号必须正确，不然STC-ISP会一直显示”正在检测目标单片机“</p><p>打开.hex文件，并选择”下载&#x2F;编程”</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709288817354-9f2f0a43-8449-4af4-9476-3b942d6e11a3.png"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709386739141-98697032-5f3e-47e6-aad5-b357c9a030b0.jpeg" alt="注意开发板冷启动，开关一下"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>P2=<span class="hljs-number">0x55</span>;<span class="hljs-comment">//0101 0101</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709387452103-fe9b57d8-7dff-472d-8849-4729fb60562a.jpeg"></p><h3 id="oHMAd">2-2 LED闪烁</h3><p>LED在亮灭之间需要延时才能由肉眼看见闪烁，可使用STC-ISP 软件的延时计算器，添加延时函数，系统频率要选择单片机旁边的晶振频率，8051指令集选STC-Y1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;INTRINS.H&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Delay500ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;<br><br>_nop_(); <span class="hljs-comment">//void,nothing but waste time</span><br>i = <span class="hljs-number">4</span>;<br>j = <span class="hljs-number">129</span>;<br>k = <span class="hljs-number">119</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--k);<br>&#125; <span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>P2=<span class="hljs-number">0xFE</span>; <span class="hljs-comment">//light one led</span><br>Delay500ms();<br>P2=<span class="hljs-number">0xFF</span>; <span class="hljs-comment">//not light</span><br>Delay500ms();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>右键打开&lt;INTRINS.H&gt; ，它定义了_nop_<img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709388920652-5fe75bc2-83b3-4e4a-9d35-83d010e3e36f.png"></p><p>注：<br>#include &lt;INTRINS.H&gt; 是一个C语言头文件，它提供了一些内嵌汇编函数，可以在C语言程序中直接使用汇编指令。 这些函数可以用于访问特殊的CPU指令集，如MMX、SSE、AVX等指令集，以及一些特殊的寄存器和操作。</p><h3 id="IOpmU">2-3 LED流水灯</h3><h4 id="KKQL7">代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;INTRINS.H&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Delay500ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@12.000MHz</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;<br><br>_nop_();<br>i = <span class="hljs-number">4</span>;<br>j = <span class="hljs-number">205</span>;<br>k = <span class="hljs-number">187</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--k);<br>&#125; <span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>P2=<span class="hljs-number">0xFE</span>;<span class="hljs-comment">//1111 1110</span><br>Delay500ms();<br>P2=<span class="hljs-number">0xFD</span>;<span class="hljs-comment">//1111 1101</span><br>Delay500ms();<br>P2=<span class="hljs-number">0xFB</span>;<span class="hljs-comment">//1111 1011</span><br>Delay500ms();<br>P2=<span class="hljs-number">0xF7</span>;<span class="hljs-comment">//1111 0111</span><br>Delay500ms();<br>P2=<span class="hljs-number">0xEF</span>;<span class="hljs-comment">//1110 1111</span><br>Delay500ms();<br>P2=<span class="hljs-number">0xDF</span>;<span class="hljs-comment">//1101 1111</span><br>Delay500ms();<br>P2=<span class="hljs-number">0xBF</span>;<span class="hljs-comment">//1011 1111</span><br>Delay500ms();<br>P2=<span class="hljs-number">0x7F</span>;<span class="hljs-comment">//0111 1111</span><br>Delay500ms();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="NZ46s">改造代码：调节流水灯的延时速度</h4><p>思路是先生成一个1ms的延时函数，此时Delay1ms()没有参数；写入参数xms， Delay1ms(xms), 但是C语言中需要指定变量的类型。（注：<font style="color:rgb(25, 27, 31);">在Python中，通常情况下不需要显式指定变量的数据类型，因为Python是一种动态类型语言，它会自动根据变量的值来确定其数据类型。R 也是）</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1ms</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;<br><br>_nop_();<br>i = <span class="hljs-number">2</span>;<br>j = <span class="hljs-number">199</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709391691606-3d22dcb6-544b-416f-a96c-d7f5b9ba3752.png"></p><p>单片机中 int 是16位的，而家用计算机是32位；只写int ，默认为(signed) int</p><p>float: 浮点型； double :双精度浮点型 ；用科学计数法表示小数</p><p>所以指定变量类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1ms</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> xms)</span><br></code></pre></td></tr></table></figure><p> 在后面调用Delay1ms()这个函数时；Delay1ms(500)，将500这个形参赋给unsigned int xms ；就可以调速</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1ms</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> xms)</span><span class="hljs-comment">//@11.0592MHz</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;<br><span class="hljs-keyword">while</span>(xms)<br>&#123;<br>i = <span class="hljs-number">2</span>;<br>j = <span class="hljs-number">199</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>xms = xms<span class="hljs-number">-1</span>; <span class="hljs-comment">//or can write xms--;</span><br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>P2=<span class="hljs-number">0xFE</span>;<span class="hljs-comment">//1111 1110</span><br>Delay1ms(<span class="hljs-number">500</span>);<br>P2=<span class="hljs-number">0xFD</span>;<span class="hljs-comment">//1111 1101</span><br>Delay1ms(<span class="hljs-number">500</span>);<br>P2=<span class="hljs-number">0xFB</span>;<span class="hljs-comment">//1111 1011</span><br>Delay1ms(<span class="hljs-number">500</span>);<br>P2=<span class="hljs-number">0xF7</span>;<span class="hljs-comment">//1111 0111</span><br>Delay1ms(<span class="hljs-number">500</span>);<br>P2=<span class="hljs-number">0xEF</span>;<span class="hljs-comment">//1110 1111</span><br>Delay1ms(<span class="hljs-number">500</span>);<br>P2=<span class="hljs-number">0xDF</span>;<span class="hljs-comment">//1101 1111</span><br>Delay1ms(<span class="hljs-number">500</span>);<br>P2=<span class="hljs-number">0xBF</span>;<span class="hljs-comment">//1011 1111</span><br>Delay1ms(<span class="hljs-number">500</span>);<br>P2=<span class="hljs-number">0x7F</span>;<span class="hljs-comment">//0111 1111</span><br>Delay1ms(<span class="hljs-number">500</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="oA9BD">三、独立按键</h3><p>普中51开发板上独立按键模块和单片机IO连接口</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709544165334-33729a7a-da8e-4f25-ac8d-a3a955f925c2.png"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709544115394-1fb25204-24fb-4c80-bb0e-af129b37584c.png"></p><p>寄存器会检测IO口的电平然后再写</p><p>P2_0是P2口其中一个LED灯；对应参见头文件&lt;REGX52.H&gt;</p><p>P3_1是开发板原理图的K1按键对应的端口号</p><h4 id="j2YoA">代码：按下点亮，松手熄灭</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(P3_1==<span class="hljs-number">0</span>)<br>&#123;<br>P2_0=<span class="hljs-number">0</span>;<span class="hljs-comment">//lightingLED</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>P2_0=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="up791">C51数据运算</h4><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709553683782-0b1e645c-f99b-49a4-9edc-1653af2d0a9f.png"></p><p>注：赋值写成 c+1&#x3D;3不可以；右边算出来给左边，不能写成解方程</p><h5 id="tOXjf">位运算</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0011</span> <span class="hljs-number">1100</span>&lt;&lt;<span class="hljs-number">1</span> <span class="hljs-comment">//按位左移1位</span><br><span class="hljs-number">0111</span> <span class="hljs-number">1000</span> <span class="hljs-comment">//移出1位后，高位补零</span><br><span class="hljs-number">0011</span> <span class="hljs-number">1100</span>&gt;&gt;<span class="hljs-number">2</span><br><span class="hljs-number">0000</span> <span class="hljs-number">1111</span><br><br><span class="hljs-number">0001</span> <span class="hljs-number">1000</span> &amp; <span class="hljs-number">0010</span> <span class="hljs-number">1010</span> <span class="hljs-comment">//按位与 -&gt; 0000 1000 //只有全真，即2个1才是1</span><br><span class="hljs-number">0001</span> <span class="hljs-number">1000</span> | <span class="hljs-number">0010</span> <span class="hljs-number">1010</span> <span class="hljs-comment">//按位或 -&gt; 1011 1010</span><br><span class="hljs-number">0001</span> <span class="hljs-number">1000</span> ^ <span class="hljs-number">0010</span> <span class="hljs-number">1010</span> <span class="hljs-comment">//按位异或 -&gt; 0011 0010 //一样为0，不一样为1</span><br>~ <span class="hljs-number">0001</span> <span class="hljs-number">1000</span> <span class="hljs-comment">//按位取反 -&gt; 1110 0111</span><br></code></pre></td></tr></table></figure><h4 id="TWqd8">C51基本语句</h4><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709555035665-f84ac3a8-6ab8-43ea-9a29-ca33e3ac31b0.png"></p>]]></content>
    
    
    <categories>
      
      <category>PC硬件</category>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
      <tag>51开发板</tag>
      
      <tag>硬件</tag>
      
      <tag>Keil</tag>
      
      <tag>stc-isp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24年5月装机8336C-双路主板安装单个CPU的注意事项</title>
    <link href="/2024/10/05/24%E5%B9%B45%E6%9C%88%E8%A3%85%E6%9C%BA8336C-%E5%8F%8C%E8%B7%AF%E4%B8%BB%E6%9D%BF%E5%AE%89%E8%A3%85%E5%8D%95%E4%B8%AACPU/"/>
    <url>/2024/10/05/24%E5%B9%B45%E6%9C%88%E8%A3%85%E6%9C%BA8336C-%E5%8F%8C%E8%B7%AF%E4%B8%BB%E6%9D%BF%E5%AE%89%E8%A3%85%E5%8D%95%E4%B8%AACPU/</url>
    
    <content type="html"><![CDATA[<h1 id="24年5月装机8336C-双路主板安装单个CPU的注意事项"><a href="#24年5月装机8336C-双路主板安装单个CPU的注意事项" class="headerlink" title="24年5月装机8336C-双路主板安装单个CPU的注意事项"></a>24年5月装机8336C-双路主板安装单个CPU的注意事项</h1><p>同23年12月的配置一样超微x12DPI-N6 主板，只是少装一个CPU。双路主板插1个CPU时，要选择cpu1的位置，内存条插法也要按说明书来。</p><p>其他都差不多，只是显卡的PCIE插槽会分配给不同的cpu，如果插错了，独立显卡将不会被识别到，一定要注意。此外，如下图所示提前进bios将 VGA Priority 改为offboard才能使用独显。</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1715264077715-bcae794b-c179-47bd-bd88-c729581f66bb.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>PC硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装机</tag>
      
      <tag>问题解决</tag>
      
      <tag>超微主板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23年7月装机EPYC7B12-技嘉MZ01-CE1</title>
    <link href="/2024/10/05/23%E5%B9%B47%E6%9C%88%E8%A3%85%E6%9C%BAEPYC7B12-%E6%8A%80%E5%98%89MZ01-CE1/"/>
    <url>/2024/10/05/23%E5%B9%B47%E6%9C%88%E8%A3%85%E6%9C%BAEPYC7B12-%E6%8A%80%E5%98%89MZ01-CE1/</url>
    
    <content type="html"><![CDATA[<h1 id="内存插满但有一个通道不识别的解决办法"><a href="#内存插满但有一个通道不识别的解决办法" class="headerlink" title="内存插满但有一个通道不识别的解决办法"></a>内存插满但有一个通道不识别的解决办法</h1><h2 id="ndYL9">问题</h2><p>实验室装机，EPYC 7B12 + 技嘉MZ01-CE1 主板，内存8通道始终有一个识别不出来，返厂维修更换CPU底座，修好送回装机还是7个通道，第8槽依然识别不出，售后说可能是主板和机箱之间短路；无奈又拆下来与机箱隔离，结果正常了，主板买家说机箱螺丝位和铜柱顶到主板。</p><h2 id="SrP2n">解决方法</h2><p>为解决短路，将机箱螺丝柱与主板用绝缘垫片隔开，不好操作；用电线将机箱外壳接地，没成功，不知道机箱本身是否带电，我们没有电笔不能测；最后将电线捆在第八槽后的螺丝柱时，小郭师姐查到机箱铜柱有可能导致主板短路，我去旁边电脑看时手正好碰到电线铜丝，突然被电了一下，于是找到背后短路的螺丝柱，此时查看任务管理器，显示只有6个内存通道，更确定这一想法。</p><p>取下多余的机箱螺丝柱，8内存通道识别正常。</p><p>事后回想，通常机箱金属柱不需要拆卸，但正好我们用的不是服务器机箱，而主板内存多（通常4通道）就取消了一个固定口，使得该<font style="color:#117CEE;">主板第八内存槽焊点与机箱金属柱短路导致内存不识别</font>。触电短路时7,8两通道突然都不识别，不知道什么原因。</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1693376216693-a6c05dae-c570-4ef3-9155-4c41f586dc29.jpeg" alt="与机箱隔离后正常"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1693367748556-9c99d00f-a8b1-4721-a234-dbd984ed4b81.jpeg" alt="拆下的机箱螺丝柱"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1693367948713-28dc0306-07a5-48bd-adb9-fa868cfc19ae.jpeg" alt="Memory 64GB少了一个"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1693368014766-fcd148c6-cb6e-49b7-af9a-3278ad3a7e7f.jpeg" alt="正常了"></p>]]></content>
    
    
    <categories>
      
      <category>PC硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装机</tag>
      
      <tag>问题解决</tag>
      
      <tag>工作站主板</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23年12月装机8336C+超微X12DPI-N6主板</title>
    <link href="/2024/10/04/23%E5%B9%B412%E6%9C%88%E8%A3%85%E6%9C%BA8336C-%E8%B6%85%E5%BE%AEX12DPI-N6%E4%B8%BB%E6%9D%BF%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/10/04/23%E5%B9%B412%E6%9C%88%E8%A3%85%E6%9C%BA8336C-%E8%B6%85%E5%BE%AEX12DPI-N6%E4%B8%BB%E6%9D%BF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="23年12月装机8336C-超微X12DPI-N6主板"><a href="#23年12月装机8336C-超微X12DPI-N6主板" class="headerlink" title="23年12月装机8336C+超微X12DPI-N6主板"></a>23年12月装机8336C+超微X12DPI-N6主板</h1><p>超微主板官网固件资源：<a href="https://www.supermicro.org.cn/support/manuals/?mlg=2">https://www.supermicro.org.cn/support/manuals/?mlg=2</a></p><h2 id="配置单"><a href="#配置单" class="headerlink" title="配置单"></a>配置单</h2><p>反复参考了好多配置，也经历了好多折腾，希望能帮助到有类似DIY需求的朋友。机器主要用来跑R，很吃内存，所以这个配置的主板内存插槽多，方便后续加；预算不够可选频率低一些的内存。</p><p>超微的说明书上写的挺详细的，提前粗看一遍手册，有时可以避免很多问题。首先看超微官网的说明, 超微x12DPI-N6 主板, 适用LGA-4189接口，支持DDR4-3200MHz内存，最大可达4TB</p><p>散热器方面，工作站PC还是不用水冷，毕竟稳定性最重要，也方便之后实验室继续维护。适配型号的散热振华那些都没出，猫头鹰家有但是太贵了，最后选了国产金钱豹牌5铜管散热，到手后感觉散热鳍片薄些，风扇没有猫家静音，但是价格一个可以抵它三个了，小风扇呼呼吹，风量还是很大的。（但这也为后面挖了个坑）。且倒霉遇上振华电源坏了，正好京东搞活动，就换成了海韵电源1000W，电源还是买质量好点的，振华某东客服又扯皮，态度很差。显卡没什么需求也可以换成二手亮机卡。<img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1709888691084-c581e767-a04a-4196-8519-5a87f35ef350.png"></p><p>24年10月记：8336C一块涨价到5800了，真成理财产品了…</p><h2 id="硬件组装"><a href="#硬件组装" class="headerlink" title="硬件组装"></a>硬件组装</h2><h3 id="散热器安装"><a href="#散热器安装" class="headerlink" title="散热器安装"></a>散热器安装</h3><p>虽然是两个CPU，组装过程也是一样的。SuperMicro主板内附赠了散热扣具支架，买散热器时就不用单独买这个支架了。</p><h3 id="内存条安装注意事项"><a href="#内存条安装注意事项" class="headerlink" title="内存条安装注意事项"></a>内存条安装注意事项</h3><p>主板上黑色的内存插槽（P1-DIMMB2 and P2-DIMMB2 ）只适用于傲腾200系列内存Intel Optane Persistent Memory 200 Series，没有就不插</p><p>内存通道组合：成对的内存条，不同的内存条数有最优的插槽插法，见主板说明书第40页</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1705577271242-a6c87d2b-a9e2-4508-ae85-9d6deb00c7e6.png"></p><ul><li>Up to 4TB 3DS ECC RDIMM, DDR4-3200MHz; Up to 4TB 3DS ECC LRDIMM, DDR4-3200MHz</li><li>Up to 4TB Intel® Optane™ Persistent Memory 200 Series, DDR4-3200MHz, in 18 DIMM slotsP1-DIMMB2 and P2-DIMMB2 are reserved for Intel Optane Persistent Memory 200 Series only.</li></ul><h3 id="机箱前面板跳线"><a href="#机箱前面板跳线" class="headerlink" title="机箱前面板跳线"></a>机箱前面板跳线</h3><p>接机箱的电源键和重启键，地线是更靠近主板边缘的针脚，不要接反了。最好先不装进机箱，先接线测试好主板是否没问题再固定进机箱。</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1705578317242-9dbad19f-3861-4274-b654-f255aaed8653.png"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1705578484082-91a8e9ac-0ce6-488c-9324-252ef0d54c93.png"></p><p>其余硬件安装没有什么特别的，电源一开始选择的是振华1300W，结果倒霉遇上它坏了，电源启动不了。下面是检测电源的方法：</p><p>拆掉电源上多余的连接线（全模组电源），只保留最粗的主板供电线18pin, 短接电源ps-on 开机信号线，再将电源连接至插头，打开电源开关，此时若电源风扇能正常匀速转动，则电源没有问题；如果不能，需联系卖家或经销商</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>前面提到散热风扇的坑，是主机启动后风扇噪音大，CPU散热器上的风扇不断启动又停止，像潮汐一样，一会儿大一会小。在B站找到了类似的情况：</p><p><a href="https://www.bilibili.com/read/cv22752140/?from=search&spm_id_from=333.337.0.0">1.解决超微 SuperMicro 主板风扇反复高低转速问题</a></p><p>解决方法是通过IPMI调整风扇转速，IPMI设置在后文；现在风扇在CPU利用率较低时保持稳定的转速，噪音肯定是有，习惯了也还好。](<a href="https://www.bilibili.com/read/cv22752140/?from=search&spm_id_from=333.337.0.0">https://www.bilibili.com/read/cv22752140/?from=search&amp;spm_id_from=333.337.0.0</a>)</p><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>win10镜像安装，下面是非常经典的2个个站；加上KMS激活，装系统非常好用</p><p><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a>  选择64位商业版 ed2k链接，打开eMule或迅雷，新建下载</p><p><a href="https://kms.cangshui.net/">https://kms.cangshui.net/</a>  KMS激活</p><p>制作引导盘：软碟通  <a href="https://www.ultraiso.net/xiazai.html">https://www.ultraiso.net/xiazai.html</a></p><p> <a href="https://zhuanlan.zhihu.com/p/326406632">https://zhuanlan.zhihu.com/p/326406632</a> 软碟通有一次试用，就够了</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1715227278997-620deaeb-b805-433b-b26d-c3059413b427.png"></p><p>进Bios修改第一启动项，超微主板按Delete 进bios</p><p>系统装好，KMS激活：<a href="https://kms.cangshui.net/">https://kms.cangshui.net/</a></p><h3 id="独立显卡显示"><a href="#独立显卡显示" class="headerlink" title="独立显卡显示"></a>独立显卡显示</h3><p>VGA Priority 改为Offboard, 不使用核显输出。在实际操作过程中，要是有vga口的显示器会更方便，它可以看到主板核显输出的内容，黑底蓝色的超微logo和故障码。</p><p>如果双路主板只装1个CPU，由于分配给每个cpu的PCIe通道不一样，显卡要插在正确的插槽位置上，不然识别不出独立显卡。</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1715313800506-ddfaaca6-e2a4-4be6-8683-520243f0cfaf.jpeg"></p><h3 id="主板驱动"><a href="#主板驱动" class="headerlink" title="主板驱动"></a>主板驱动</h3><p>超微X12D主板驱动：<a href="https://www.supermicro.org.cn/zh_cn/support/resources/drivers">https://www.supermicro.org.cn/zh_cn&#x2F;support&#x2F;resources&#x2F;drivers</a></p><h3 id="BMC-x2F-IPMI"><a href="#BMC-x2F-IPMI" class="headerlink" title="BMC&#x2F;IPMI"></a>BMC&#x2F;IPMI</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/597490170">超微主板使用配置 ipmi 功能流程介绍 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/qq_37592750/article/details/129804569">超微（Supermicro）主板的IPMI接口IP地址配置【笔记】_超微ipmi-CSDN博客</a></p><p>首先将网线插入主板上的 IPMI 网口，说明书会说具体是哪一个网口，要设置地址 ：<br>进入bios 的 BMC network configuration 选项，将将Configuration Address source 改为Dynamic模式，即设置为用dhcp方式从上游获取网络环境信息。填写好获取到的当前的IP地址，完成设置。</p><p>从同一局域网的电脑打开浏览器访问对应地址，出现 ipmi 登录界面，老的超微主板可以使用 ipmi默认密码ADMIN&#x2F;ADMIN。但可惜这块主板不行，现在超微的IPMI账号密码都在主板保护cpu针脚的塑料盖子上，装机时别丢掉了！<br><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728031813877-310c05cd-d0c9-4631-bfea-db31e2313de4.jpeg"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728031927519-5c66acfc-83e3-4adc-8c1f-937caa37acff.jpeg"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728031999244-1518c8f9-1439-43e9-9995-79dca0578fe9.jpeg"></p><p>Username: 输入灰色盖子上的BMC序列号<br>Password: PWD序列号</p>]]></content>
    
    
    <categories>
      
      <category>PC硬件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装机</tag>
      
      <tag>工作站主板</tag>
      
      <tag>服务器</tag>
      
      <tag>电子产品</tag>
      
      <tag>DIY 配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器连接群晖NAS</title>
    <link href="/2024/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E7%BE%A4%E6%99%96NAS/"/>
    <url>/2024/10/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E7%BE%A4%E6%99%96NAS/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器连接群晖NAS"><a href="#服务器连接群晖NAS" class="headerlink" title="服务器连接群晖NAS"></a>服务器连接群晖NAS</h1><h2 id="cbVuz">问题需求</h2><p>(1) nas和A地点的电脑用同一个路由器相连，可以访问；</p><p>(2) 我们需求是想在另一个B地点对nas进行访问，所以需要调IP区段；</p><p>(3) 学校信息部反馈nas必须直接连接网口，不连接路由器才能调IP区段，现在连接网口后nas无法使用。（后记：在校园内的网络设备基本上都在一个IP区段，但是设备经过路由器就变成运营商的IP区段了；所以只要设备直连网口不接路由器，就不用让学校信息部调IP区段，因为设备已经在同一个区段）</p><p>与NAS处于一个网络下的电脑，可以访问到NAS的内容；之前的NAS是连在路由器下的，这样在同一个WIFI下的设备都可以访问到NAS；但是服务器不在同一个WIFI下，如何访问NAS呢？</p><p>可以做内网穿透，但是这样速度比较慢；做内网穿透的软件有的按流量计费，不划算</p><p>所以直接走校园网内网，访问速度快，下面是设置方法：</p><h2 id="tDBYL">解决方法</h2><h3 id="rzTJ0">检测服务器是否能访问NAS</h3><p>先ping 一下服务器IP地址，失败</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728046559808-f35f8565-6569-40fc-ab7a-3eca6d32aa65.jpeg"></p><h3 id="P2rxE">获得IP地址</h3><p>首先要获得网口的IP地址：</p><p>如果是使用校园网&#x2F;局域网，首先登录账号，确认这个网口的网络可以使用</p><p>拿一个带网口的笔记本，网线连接网口和笔记本，同时按下win+R ,输入ipconfig,获得IPV4地址</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728034863829-a6f88a50-796b-4ef3-8515-0d5876e3f27c.jpeg"></p><h3 id="ybaeH">安装群晖Synology Assistant</h3><p>Synology Assistant是用来搜索群晖NAS设备，在笔记本电脑上安装好软件后，将网线连接NAS后的网口和笔记本即可检索NAS设备。</p><p>群晖官网找到相应设备型号的Synology Assistant：<a href="https://www.synology.cn/zh-cn/support/download/DS1821+?version=7.1#utilities">下载中心 - DS1821+ | Synology 群晖科技</a></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728035642525-70e5d195-8a4b-4cec-b0cd-5b9e7f700131.png"></p><p>如果提示找不到服务器：关闭windows防火墙，点开软件右上角齿轮图标，勾选一下兼容性</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728035904644-a8272070-e7bd-4e99-855d-b2f829aa846d.png"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728035925479-1bbd098c-b16d-4422-9a9e-7bd5f3dd175c.png"></p><p>勾选兼容性</p><h3 id="fO6DH">浏览器NAS管理员账号设置</h3><p>笔记本能检索到NAS后，在浏览器登录NAS管理员账号（或者叫做Synology账户）</p><p>如下图依次点击：控制面板-网络-网络界面-局域网1（写着静态IP的）-编辑； 在弹出的编辑界面填写之前我们从网口获得的IP地址和网关</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728036207037-148e9378-a1d0-49dc-bbea-49ebb1b8dd29.png"></p><h3 id="lfOJ6">NFS设置开启</h3><h4 id="iKOUS">NFS是什么？</h4><p>NFS(Network File System)的缩写，它最大的功能就是可以<strong>通过网络，让不同的机器、不同的操作系统可以共享彼此的文件</strong>。例如我们在浏览器上就能访问到NAS里的数据</p><h4 id="JkH4u">NFS开启</h4><p>群晖设备支持多种协议可供文件共享访问；</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728036876127-7dcc2e42-53b2-4265-98e3-ec2bd4cbf4d3.png"></p><p>NFS默认没有开启，点击控制面板-文件服务-NFS</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/1728036889161-a1b00c92-d8dc-4534-901b-7325bb8f1124.png"></p><h3 id="WCcxP">服务器挂载NAS</h3><p><a href="https://blog.csdn.net/xiaominggunchuqu/article/details/78912330">https://blog.csdn.net/xiaominggunchuqu/article/details/78912330</a></p><h3 id="yszih">附：快速访问NAS</h3><p>与NAS同在一个网络下的设备，可以在桌面新建快捷方式，键入对象的位置输入\xxx.xx.x.xxx</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>NAS</tag>
      
      <tag>群晖</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年6月18日 深圳车展（二）</title>
    <link href="/2023/12/13/2023%E5%B9%B46%E6%9C%8818%E6%97%A5-%E6%B7%B1%E5%9C%B3%E8%BD%A6%E5%B1%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/12/13/2023%E5%B9%B46%E6%9C%8818%E6%97%A5-%E6%B7%B1%E5%9C%B3%E8%BD%A6%E5%B1%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="2023年6月18日-深圳新能源车展（二）"><a href="#2023年6月18日-深圳新能源车展（二）" class="headerlink" title="2023年6月18日 深圳新能源车展（二）"></a>2023年6月18日 深圳新能源车展（二）</h1><h2 id="捷豹JAGUAR"><a href="#捷豹JAGUAR" class="headerlink" title="捷豹JAGUAR"></a>捷豹JAGUAR</h2><p>F-TYPE  75周年典藏硬顶版</p><p>黑色的外观套件，经典的前翻机盖设计。</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231216174546700.png" alt="image-20231216174546700"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231216174631598.png" alt="image-20231216174631598"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/IMG_20230618_161714.jpg" alt="IMG_20230618_161714"></p><h2 id="奔驰-Mercedes-Benz-AMG"><a href="#奔驰-Mercedes-Benz-AMG" class="headerlink" title="奔驰 Mercedes-Benz  AMG"></a>奔驰 Mercedes-Benz  AMG</h2><p>AMG GT50 2022款</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231225222541063.png" alt="image-20231225222541063"></p><h2 id="梅赛德斯-迈巴赫-Mercedes-Maybach"><a href="#梅赛德斯-迈巴赫-Mercedes-Maybach" class="headerlink" title="梅赛德斯-迈巴赫  Mercedes-Maybach"></a>梅赛德斯-迈巴赫  Mercedes-Maybach</h2><p> Mercedes-Maybach S580 e</p><p>是的，它是一台插混的行政级轿车</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231225222629915.png" alt="image-20231225222629915"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>车展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>车展</tag>
      
      <tag>跑车</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年6月18日 深圳车展</title>
    <link href="/2023/12/10/2023%E5%B9%B46%E6%9C%8818%E6%97%A5-%E6%B7%B1%E5%9C%B3%E8%BD%A6%E5%B1%95/"/>
    <url>/2023/12/10/2023%E5%B9%B46%E6%9C%8818%E6%97%A5-%E6%B7%B1%E5%9C%B3%E8%BD%A6%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2023年6月18日-深圳新能源车展"><a href="#2023年6月18日-深圳新能源车展" class="headerlink" title="2023年6月18日 深圳新能源车展"></a>2023年6月18日 深圳新能源车展</h1><p>23年6月18和同门去了“粤港澳大湾区车展”，类似展销会，没有什么新车发布。展区的车以家用车为主，最火热的是比亚迪等国产新能源车企的展区，人山人海，我只拍了部分感兴趣的车。</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027144251424.png" alt="image-20231027144251424"></p><center style="color:#C0C0C0;text-decoration:underline">入口</center><h2 id="现代HYUNDAI"><a href="#现代HYUNDAI" class="headerlink" title="现代HYUNDAI"></a>现代HYUNDAI</h2><p>问了现代展区的工作人员，现代伊兰特N还未确认引进。8月25日成都车展现代伊兰特N 开启预售25.98万起，价格颇有竞争力。而且之前看B站UP“键盘车神教”这个车赛道圈速特好。更难得的是，在几乎所有品牌全面电气化的时代，还有车企肯出燃油性能车。</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027144718071.png" alt="image-20231027144718071"></p><h2 id="雪佛兰Chevrolet"><a href="#雪佛兰Chevrolet" class="headerlink" title="雪佛兰Chevrolet"></a>雪佛兰Chevrolet</h2><p>改装机甲风包围的迈锐宝XL，就是走近看后翼子板的腻子开裂了，赶工有点粗糙</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231210151423204.png" alt="image-20231210151423204"></p><h2 id="丰田TOYOTA"><a href="#丰田TOYOTA" class="headerlink" title="丰田TOYOTA"></a>丰田TOYOTA</h2><p>23款 GR Supra  ,与BMW Z4搭载同款2.0T&#x2F; 3.0T引擎</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027152413796.png" alt="image-20231027152413796"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027151348519.png" alt="image-20231027151348519"></p><p>双色轮毂很精致</p><h2 id="斯巴鲁SUBARU"><a href="#斯巴鲁SUBARU" class="headerlink" title="斯巴鲁SUBARU"></a>斯巴鲁SUBARU</h2><p>22款SUBARU BRZ 手动变速箱车内布局紧凑，坐进去视野很低，但是座椅包裹感很强，真的像一个大玩具</p><p>春节期间见到家附近停了一辆银色的BRZ, 也很好看</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027153319485.png" alt="image-20231027153319485"></p><center style="color:#C0C0C0;text-decoration:underline">帅气前脸</center><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027153506900.png" alt="image-20231027153506900"></p><center style="color:#C0C0C0;text-decoration:underline">经典拉力蓝 </center><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027153537938.png" alt="image-20231027153537938"></p><h2 id="路特斯Lotus"><a href="#路特斯Lotus" class="headerlink" title="路特斯Lotus"></a>路特斯Lotus</h2><h3 id="Lotus-EMIRA"><a href="#Lotus-EMIRA" class="headerlink" title="Lotus EMIRA"></a>Lotus EMIRA</h3><p>Lotus EMIRA 3.5L 机械增压 V6 2GR-FE全铝发动机，搭配6速手动变速箱，机械液压助力转向，整备质量1493kg ；还有另一个2.0T的版本，使用8速双离合变速箱和电动液压助力转向，整备质量1460kg，只能说V6的机器即使是铝制发动机也还是会重些，但1.4吨多的小车也不算重</p><p>全面电气化的莲花, 最后的燃油绝唱（官网自己说的）没有拍全，侧面有点奇怪，后尾动感上翘，实车还是非常精致</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027205843627.png" alt="image-20231027205843627"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027205926791.png" alt="image-20231027205926791"></p><center style="color:#C0C0C0;text-decoration:underline">后置V6机增</center><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231027205953245.png" alt="image-20231027205953245"></p><h3 id="ELETRE"><a href="#ELETRE" class="headerlink" title="ELETRE"></a>ELETRE</h3><p>纯电超跑SUV,6活塞红色制动卡钳，碳陶瓷刹车盘，如果配上22英寸的双色刀锋式五辐轮毂就更帅了。作为电车，但匹配了两档变速箱，官网没有给出它的整备质量，参考汽车之家大约是2600kg；</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231031175559507.png" alt="image-20231031175559507"></p><h2 id="保时捷Porsche"><a href="#保时捷Porsche" class="headerlink" title="保时捷Porsche"></a>保时捷Porsche</h2><h3 id="911-GT3-RS"><a href="#911-GT3-RS" class="headerlink" title="911 GT3 RS"></a>911 GT3 RS</h3><p>工作人员介绍，该车是亚洲地区限定，300万RMB 配置不可更改，对于一台911 GT3 RS来说是挺有性价比了，但300万买一台不能上路的GT3 赛车，真的是非常奢侈的大玩具。</p><p>该车作为保时捷自吸发动机的最强性能版本，将搭载强化后的4.0L自然吸气水平对置六缸发动机，最大功率提升至525马力，0-100km&#x2F;h加速时间仅为3.2秒，在全长20.8公里的纽博格林北环赛道做出了6:49.328的单圈成绩，再次刷新911 GT3 RS车型的圈速记录。(来源：<a href="http://www.autohome.com.cn/">www.autohome.com.cn</a>)</p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231203173050932.png" alt="image-20231203173050932"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231203173212560.png" alt="image-20231203173212560"></p><h3 id="718-SPYDER"><a href="#718-SPYDER" class="headerlink" title="718 SPYDER"></a>718 SPYDER</h3><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231209212014582.png" alt="image-20231209212014582"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231209212119222.png" alt="image-20231209212119222"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231209212207166.png" alt="image-20231209212207166"></p><h3 id="Panamera"><a href="#Panamera" class="headerlink" title="Panamera"></a>Panamera</h3><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231209212351731.png" alt="image-20231209212351731"></p><p><img src="https://typora-blog-1316195201.cos.ap-guangzhou.myqcloud.com/picture/image-20231209212446518.png" alt="image-20231209212446518"></p><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>车展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>车展</tag>
      
      <tag>跑车</tag>
      
      <tag>新能源汽车</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/05/15/hello-world/"/>
    <url>/2023/05/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
